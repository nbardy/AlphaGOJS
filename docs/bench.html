<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>AlphaPlague Benchmarks</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.22.0/dist/tf-backend-wasm.min.js"></script>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#0a0a1a; color:#c0c0e0; font-family:'Courier New',monospace; padding:20px; }
h1 { color:#00ff88; text-align:center; margin-bottom:4px; }
.subtitle { text-align:center; color:#556; font-size:12px; margin-bottom:20px; }
#controls { display:flex; justify-content:center; gap:10px; margin-bottom:20px; flex-wrap:wrap; }
button { background:#2244aa; color:#fff; border:none; padding:10px 20px; border-radius:6px;
  cursor:pointer; font-family:inherit; font-size:14px; }
button:hover { background:#3355cc; }
button:disabled { background:#333; color:#666; cursor:default; }
button.run { background:#008844; }
button.run:hover:not(:disabled) { background:#00aa55; }
#status { text-align:center; margin:10px 0; font-size:14px; color:#ffcc00; min-height:20px; }
table { width:100%; max-width:1400px; margin:10px auto; border-collapse:collapse; font-size:12px; }
th, td { padding:5px 8px; border:1px solid #2a2a5a; text-align:right; white-space:nowrap; }
th { background:#151530; color:#6666aa; text-transform:uppercase; font-size:10px; letter-spacing:1px; }
th.sub { font-size:9px; color:#556; }
td:first-child { text-align:left; color:#aac; font-weight:bold; }
tr.section-header td { background:#1a1a40; color:#4488ff; font-size:12px; text-align:left;
  letter-spacing:1px; text-transform:uppercase; }
.fastest { color:#00ff88; font-weight:bold; }
.slowest { color:#ff3366; }
.na { color:#444; }
.moe { color:#555; font-size:10px; }
.kernel-val { color:#88aaff; font-size:11px; }
#results-wrap { max-width:1400px; margin:0 auto; overflow-x:auto; }
#progress-bar { width:100%; max-width:600px; margin:10px auto; height:6px; background:#1a1a40;
  border-radius:3px; overflow:hidden; }
#progress-fill { height:100%; width:0%; background:#00ff88; transition:width 0.3s; }
#methodology { max-width:900px; margin:20px auto; padding:14px; background:#0e0e24;
  border:1px solid #2a2a5a; border-radius:6px; font-size:11px; color:#667; line-height:1.6; }
#methodology b { color:#8888bb; }
#methodology code { color:#88aaff; background:#151530; padding:1px 4px; border-radius:3px; }
</style>
</head>
<body>

<h1>AlphaPlague Benchmarks</h1>
<div class="subtitle">TF.js backend comparison &mdash; CPU vs WASM vs WebGL vs WebGPU</div>

<div id="controls">
  <button class="run" onclick="runAll()">Run All Backends</button>
  <button onclick="runSingle('cpu')">CPU</button>
  <button onclick="runSingle('wasm')">WASM</button>
  <button onclick="runSingle('webgl')">WebGL</button>
  <button onclick="runSingle('webgpu')">WebGPU</button>
</div>
<div id="status"></div>
<div id="progress-bar"><div id="progress-fill"></div></div>
<div id="results-wrap"></div>

<div id="methodology">
  <b>Methodology:</b><br>
  <b>CPU ops</b> (spread, softmax, render): timed with <code>performance.now()</code> after 500-iter
  JIT warm-up. Auto-calibrated iteration count (min 50ms per round). 15 sample rounds,
  reporting <b>median &plusmn; MAD</b>. All results flow into a global sink to prevent dead code elimination.<br>
  <b>GPU ops</b> (forward, train, tick): timed with <code>tf.time()</code> which reports <b>kernel ms</b>
  (pure GPU/WASM compute) and <b>wall ms</b> (total including JS dispatch + data transfer).
  Table shows wall time as primary with kernel time annotated. Each iteration wrapped in
  <code>tf.tidy()</code> to prevent VRAM leaks. Shader warm-up via initial dummy runs with matching tensor shapes.
  15 async sample rounds with GC yield between each.
</div>

<script>
// ═══════════════════════════════════════════════════════════
//  Benchmarking harness
//
//  Two measurement modes:
//    measureCPU(fn) — performance.now() for plain JS ops
//    measureGPU(fn) — tf.time() for TF.js ops, gives kernel + wall
// ═══════════════════════════════════════════════════════════

// DCE sink — accumulated and logged at end so V8 can't eliminate work
var __sink = 0;
function sinkValue(v) {
  if (typeof v === 'number') { __sink += v; }
  else if (v && v.length !== undefined) { __sink += v[0]; }
  else if (v) { __sink += 1; }
}

function sleep(ms) { return new Promise(function(r) { setTimeout(r, ms); }); }
function status(msg) { document.getElementById('status').textContent = msg; }
function progress(pct) { document.getElementById('progress-fill').style.width = pct + '%'; }

var WARMUP_ITERS = 500;
var SAMPLE_ROUNDS = 15;
var MIN_ROUND_MS = 50;

function medianMad(arr) {
  arr.sort(function(a, b) { return a - b; });
  var med = arr[Math.floor(arr.length / 2)];
  var devs = arr.map(function(v) { return Math.abs(v - med); });
  devs.sort(function(a, b) { return a - b; });
  var mad = devs[Math.floor(devs.length / 2)];
  return { median: med, mad: mad };
}

// ─── CPU measurement (plain JS ops) ───
// Returns { wall: { median, mad } }
async function measureCPU(fn) {
  for (var i = 0; i < WARMUP_ITERS; i++) fn();

  // Calibrate ops per round
  var calStart = performance.now();
  var calOps = 0;
  while (performance.now() - calStart < MIN_ROUND_MS) {
    fn(); fn(); fn(); fn(); fn();
    fn(); fn(); fn(); fn(); fn();
    calOps += 10;
  }
  var opsPerRound = Math.max(10, Math.ceil(calOps * MIN_ROUND_MS / (performance.now() - calStart)));

  var wallSamples = [];
  for (var round = 0; round < SAMPLE_ROUNDS; round++) {
    await sleep(1); // GC yield
    var start = performance.now();
    for (var i = 0; i < opsPerRound; i++) fn();
    wallSamples.push((performance.now() - start) / opsPerRound);
  }

  return { wall: medianMad(wallSamples), kernel: null };
}

// ─── GPU measurement (TF.js ops) ───
// Uses tf.time() to get kernelMs (actual GPU compute) + wallMs (total round-trip).
// Each iteration wrapped in tf.tidy() to prevent VRAM leaks.
// Returns { wall: { median, mad }, kernel: { median, mad } }
async function measureGPU(fn) {
  // Shader warm-up: run with matching shapes so shaders compile before timing
  for (var i = 0; i < 5; i++) {
    await tf.time(function() { tf.tidy(fn); });
  }

  // Calibrate: how many ops per round to fill MIN_ROUND_MS
  var calStart = performance.now();
  var calOps = 0;
  while (performance.now() - calStart < MIN_ROUND_MS) {
    tf.tidy(fn);
    calOps++;
  }
  var opsPerRound = Math.max(3, Math.ceil(calOps * MIN_ROUND_MS / (performance.now() - calStart)));

  var wallSamples = [];
  var kernelSamples = [];
  for (var round = 0; round < SAMPLE_ROUNDS; round++) {
    await sleep(2); // GC + GPU queue drain
    var roundWall = 0;
    var roundKernel = 0;
    for (var i = 0; i < opsPerRound; i++) {
      var timing = await tf.time(function() { tf.tidy(fn); });
      roundWall += timing.wallMs;
      roundKernel += timing.kernelMs;
    }
    wallSamples.push(roundWall / opsPerRound);
    kernelSamples.push(roundKernel / opsPerRound);
  }

  return { wall: medianMad(wallSamples), kernel: medianMad(kernelSamples) };
}

// ─── Board configs and batch sizes ───
var BOARD_CONFIGS = [
  { rows: 5, cols: 5, label: '5x5' },
  { rows: 10, cols: 10, label: '10x10' },
  { rows: 19, cols: 19, label: '19x19' },
];
var BATCH_SIZES = [1, 10, 40, 100];
var results = {};
var running = false;

// ═══════════════════════════════════
//  Functions under test
// ═══════════════════════════════════

function spreadPlague(board, rows, cols) {
  var newBoard = Int8Array.from(board);
  for (var r = 0; r < rows; r++) {
    for (var c = 0; c < cols; c++) {
      var i = r * cols + c;
      if (board[i] !== 0) continue;
      var sum = 0;
      if (r > 0) sum += board[(r - 1) * cols + c] * Math.random();
      if (r < rows - 1) sum += board[(r + 1) * cols + c] * Math.random();
      if (c > 0) sum += board[r * cols + (c - 1)] * Math.random();
      if (c < cols - 1) sum += board[r * cols + (c + 1)] * Math.random();
      newBoard[i] = Math.max(-1, Math.min(1, Math.trunc(sum * 2)));
    }
  }
  return newBoard;
}

function maskedSoftmax(logits, mask) {
  var n = logits.length;
  var probs = new Float32Array(n);
  var maxVal = -Infinity;
  for (var i = 0; i < n; i++) {
    if (mask[i] > 0 && logits[i] > maxVal) maxVal = logits[i];
  }
  if (maxVal === -Infinity) return probs;
  var sum = 0;
  for (var i = 0; i < n; i++) {
    if (mask[i] > 0) { probs[i] = Math.exp(logits[i] - maxVal); sum += probs[i]; }
  }
  if (sum > 1e-8) for (var i = 0; i < n; i++) probs[i] /= sum;
  return probs;
}

function renderBoard(canvas, board, rows, cols, cs) {
  var ctx = canvas.getContext('2d');
  ctx.fillStyle = '#0d0d22';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  for (var r = 0; r < rows; r++) {
    for (var c = 0; c < cols; c++) {
      var val = board[r * cols + c];
      ctx.fillStyle = val === 1 ? '#00ff88' : val === -1 ? '#ff3366' : '#1e1e3a';
      ctx.fillRect(c * cs, r * cs, cs - 1, cs - 1);
    }
  }
}

function randomBoard(size) {
  var board = new Int8Array(size);
  for (var i = 0; i < size; i++) {
    var r = Math.random();
    board[i] = r < 0.33 ? 1 : r < 0.66 ? -1 : 0;
  }
  return board;
}

function buildDenseModel(boardSize) {
  var input = tf.input({ shape: [boardSize] });
  var x = tf.layers.dense({ units: 256, activation: 'relu' }).apply(input);
  x = tf.layers.dense({ units: 128, activation: 'relu' }).apply(x);
  var policy = tf.layers.dense({ units: boardSize }).apply(x);
  var value = tf.layers.dense({ units: 1, activation: 'tanh' }).apply(x);
  var combined = tf.layers.concatenate().apply([policy, value]);
  return tf.model({ inputs: input, outputs: combined });
}

function buildSpatialModel(rows, cols) {
  var boardSize = rows * cols;
  var input = tf.input({ shape: [boardSize] });
  var reshaped = tf.layers.reshape({ targetShape: [rows, cols, 1] }).apply(input);
  var x = tf.layers.conv2d({ filters: 32, kernelSize: 3, padding: 'same', activation: 'relu' }).apply(reshaped);
  for (var b = 0; b < 3; b++) {
    var c1 = tf.layers.conv2d({ filters: 32, kernelSize: 3, padding: 'same', activation: 'relu' }).apply(x);
    var c2 = tf.layers.conv2d({ filters: 32, kernelSize: 3, padding: 'same' }).apply(c1);
    var added = tf.layers.add().apply([x, c2]);
    x = tf.layers.activation({ activation: 'relu' }).apply(added);
  }
  var pConv = tf.layers.conv2d({ filters: 2, kernelSize: 1, padding: 'same', activation: 'relu' }).apply(x);
  var pol = tf.layers.dense({ units: boardSize }).apply(tf.layers.flatten().apply(pConv));
  var vConv = tf.layers.conv2d({ filters: 1, kernelSize: 1, padding: 'same', activation: 'relu' }).apply(x);
  var vFlat = tf.layers.flatten().apply(vConv);
  var vDense = tf.layers.dense({ units: 64, activation: 'relu' }).apply(vFlat);
  var val = tf.layers.dense({ units: 1, activation: 'tanh' }).apply(vDense);
  var combined = tf.layers.concatenate().apply([pol, val]);
  return tf.model({ inputs: input, outputs: combined });
}

// ═══════════════════════════════════════════════════
//  Benchmark wrappers
//  CPU ops: measureCPU + sinkValue for DCE
//  GPU ops: measureGPU + tf.tidy inside each iter
// ═══════════════════════════════════════════════════

function benchSpread(rows, cols) {
  var board = randomBoard(rows * cols);
  return measureCPU(function() {
    board = spreadPlague(board, rows, cols);
    sinkValue(board);
  });
}

function benchSoftmax(boardSize) {
  var logits = new Float32Array(boardSize);
  var mask = new Float32Array(boardSize);
  for (var i = 0; i < boardSize; i++) {
    logits[i] = Math.random() * 2 - 1;
    mask[i] = Math.random() > 0.3 ? 1 : 0;
  }
  return measureCPU(function() {
    sinkValue(maskedSoftmax(logits, mask));
  });
}

function benchRender(rows, cols) {
  var cs = Math.max(2, Math.floor(200 / Math.max(rows, cols)));
  var canvas = document.createElement('canvas');
  canvas.width = cols * cs; canvas.height = rows * cs;
  var board = randomBoard(rows * cols);
  return measureCPU(function() {
    renderBoard(canvas, board, rows, cols, cs);
  });
}

function benchForward(model, boardSize, batchSize) {
  // Pre-allocate input data so we only measure model.predict
  var inputData = new Float32Array(batchSize * boardSize);
  for (var i = 0; i < inputData.length; i++) inputData[i] = Math.random() * 2 - 1;

  return measureGPU(function() {
    // tf.tidy handles intermediates inside predict.
    // We create input + read output here because that's what the real app does.
    var input = tf.tensor2d(inputData, [batchSize, boardSize]);
    var out = model.predict(input);
    sinkValue(out.dataSync()); // force GPU sync + DCE prevention
    out.dispose();
    input.dispose();
  });
}

function benchTrain(model, boardSize, batchSize) {
  var optimizer = tf.train.adam(0.001);
  var result = measureGPU(function() {
    var states = tf.randomNormal([batchSize, boardSize]);
    var actionMask = tf.zeros([batchSize, boardSize]);
    var rewards = tf.randomNormal([batchSize]);
    var loss = optimizer.minimize(function() {
      var combined = model.predict(states);
      var logits = combined.slice([0, 0], [-1, boardSize]);
      var preds = logits.softmax();
      var selected = preds.mul(actionMask).sum(1);
      var logProbs = selected.add(tf.scalar(1e-8)).log();
      var policyLoss = logProbs.mul(rewards).mean().neg();
      var entropy = preds.add(tf.scalar(1e-8)).log().mul(preds).sum(1).mean().neg();
      return policyLoss.sub(entropy.mul(tf.scalar(0.01)));
    }, true);
    if (loss) { sinkValue(loss.dataSync()[0]); loss.dispose(); }
    states.dispose(); actionMask.dispose(); rewards.dispose();
  });
  optimizer.dispose();
  return result;
}

function benchFullTick(model, rows, cols, numGames) {
  var size = rows * cols;
  var boards = [];
  for (var g = 0; g < numGames; g++) boards.push(randomBoard(size));

  // Full tick is mixed JS + GPU — use measureGPU so we get kernel vs wall breakdown
  return measureGPU(function() {
    for (var g = 0; g < numGames; g++) boards[g] = spreadPlague(boards[g], rows, cols);
    var flat = new Float32Array(numGames * size);
    for (var g = 0; g < numGames; g++)
      for (var i = 0; i < size; i++) flat[g * size + i] = boards[g][i];
    var input = tf.tensor2d(flat, [numGames, size]);
    var out = model.predict(input);
    sinkValue(out.dataSync());
    out.dispose(); input.dispose();
    for (var g = 0; g < numGames; g++) boards[g] = spreadPlague(boards[g], rows, cols);
  });
}

// ═══════════════════════════════════
//  Backend orchestration
// ═══════════════════════════════════

async function setBackend(name) {
  if (name === 'webgpu' && !navigator.gpu) throw new Error('WebGPU not available');
  await tf.setBackend(name);
  await tf.ready();
}

async function benchmarkBackend(backend, onProgress) {
  status('Setting backend: ' + backend + '...');
  try { await setBackend(backend); } catch (e) {
    status(backend + ': ' + e.message);
    return null;
  }
  status('Running on ' + backend + '...');
  await sleep(100);

  var r = { backend: backend };
  var totalSteps = BOARD_CONFIGS.length * (3 + BATCH_SIZES.length * 2 + 3);
  var step = 0;

  for (var bi = 0; bi < BOARD_CONFIGS.length; bi++) {
    var bc = BOARD_CONFIGS[bi];
    var size = bc.rows * bc.cols;
    var key = bc.label;

    // CPU-only benchmarks (backend-independent, measure once)
    if (backend === 'cpu' || !results['cpu']) {
      status(backend + ' | ' + key + ' | plague spread...');
      await sleep(10);
      r['spread_' + key] = await benchSpread(bc.rows, bc.cols);
      step++; onProgress(step, totalSteps);

      status(backend + ' | ' + key + ' | masked softmax...');
      await sleep(10);
      r['softmax_' + key] = await benchSoftmax(size);
      step++; onProgress(step, totalSteps);

      status(backend + ' | ' + key + ' | canvas render...');
      await sleep(10);
      r['render_' + key] = await benchRender(bc.rows, bc.cols);
      step++; onProgress(step, totalSteps);
    } else {
      r['spread_' + key] = results['cpu']['spread_' + key];
      r['softmax_' + key] = results['cpu']['softmax_' + key];
      r['render_' + key] = results['cpu']['render_' + key];
      step += 3; onProgress(step, totalSteps);
    }

    // Dense model
    status(backend + ' | ' + key + ' | building dense model...');
    await sleep(10);
    var denseModel = buildDenseModel(size);

    for (var si = 0; si < BATCH_SIZES.length; si++) {
      var bs = BATCH_SIZES[si];
      status(backend + ' | ' + key + ' | dense forward batch=' + bs + '...');
      await sleep(10);
      r['dense_fwd_' + key + '_b' + bs] = await benchForward(denseModel, size, bs);
      step++; onProgress(step, totalSteps);
    }

    status(backend + ' | ' + key + ' | dense train batch=64...');
    await sleep(10);
    r['dense_train_' + key + '_b64'] = await benchTrain(denseModel, size, 64);
    step++; onProgress(step, totalSteps);

    status(backend + ' | ' + key + ' | dense train batch=256...');
    await sleep(10);
    r['dense_train_' + key + '_b256'] = await benchTrain(denseModel, size, 256);
    step++; onProgress(step, totalSteps);

    status(backend + ' | ' + key + ' | full tick (40 games)...');
    await sleep(10);
    r['tick_' + key] = await benchFullTick(denseModel, bc.rows, bc.cols, 40);
    step++; onProgress(step, totalSteps);

    denseModel.dispose();

    // Spatial model (skip 5x5)
    if (size >= 100) {
      status(backend + ' | ' + key + ' | building spatial model...');
      await sleep(10);
      var spatialModel = buildSpatialModel(bc.rows, bc.cols);

      for (var si = 0; si < BATCH_SIZES.length; si++) {
        var bs = BATCH_SIZES[si];
        status(backend + ' | ' + key + ' | spatial forward batch=' + bs + '...');
        await sleep(10);
        r['spatial_fwd_' + key + '_b' + bs] = await benchForward(spatialModel, size, bs);
        step++; onProgress(step, totalSteps);
      }

      status(backend + ' | ' + key + ' | spatial train batch=64...');
      await sleep(10);
      r['spatial_train_' + key + '_b64'] = await benchTrain(spatialModel, size, 64);
      step++; onProgress(step, totalSteps);

      spatialModel.dispose();
    }
  }

  return r;
}

// ═══════════════════════════════════
//  Results table
// ═══════════════════════════════════

function fmtMs(ms, mad) {
  if (ms == null) return '<span class="na">&mdash;</span>';
  var v, m;
  if (ms < 0.01) { v = (ms*1000).toFixed(1) + '&mu;s'; m = (mad*1000).toFixed(1); }
  else if (ms < 1) { v = ms.toFixed(3) + 'ms'; m = mad.toFixed(3); }
  else if (ms < 100) { v = ms.toFixed(2) + 'ms'; m = mad.toFixed(2); }
  else { v = ms.toFixed(0) + 'ms'; m = mad.toFixed(0); }
  return v + ' <span class="moe">&plusmn;' + m + '</span>';
}

function renderResults() {
  var wrap = document.getElementById('results-wrap');
  var backends = Object.keys(results);
  if (backends.length === 0) { wrap.innerHTML = ''; return; }

  // Each backend gets 2 sub-columns: wall | kernel
  var html = '<table><thead>';
  html += '<tr><th rowspan="2">Benchmark</th>';
  backends.forEach(function(b) {
    html += '<th colspan="2">' + b.toUpperCase() + '</th>';
  });
  html += '</tr><tr>';
  backends.forEach(function() {
    html += '<th class="sub">wall</th><th class="sub">kernel</th>';
  });
  html += '</tr></thead><tbody>';

  var totalCols = 1 + backends.length * 2;

  function sectionRow(label) {
    return '<tr class="section-header"><td colspan="' + totalCols + '">' + label + '</td></tr>';
  }

  function row(label, keyFn) {
    var stats = backends.map(function(b) { return results[b] ? keyFn(results[b]) : null; });
    // Find fastest wall time for highlighting
    var wallMedians = stats.map(function(s) { return s && s.wall ? s.wall.median : Infinity; });
    var minWall = Math.min.apply(null, wallMedians);

    var s = '<tr><td>' + label + '</td>';
    for (var i = 0; i < stats.length; i++) {
      var st = stats[i];
      var wallCls = '';
      if (st && st.wall && backends.length > 1) {
        if (wallMedians[i] === minWall) wallCls = 'fastest';
        else if (wallMedians[i] > minWall * 3) wallCls = 'slowest';
      }
      // Wall column
      var wallHtml = (st && st.wall) ? fmtMs(st.wall.median, st.wall.mad) : '<span class="na">&mdash;</span>';
      s += '<td class="' + wallCls + '">' + wallHtml + '</td>';
      // Kernel column
      var kernelHtml = (st && st.kernel) ? '<span class="kernel-val">' + fmtMs(st.kernel.median, st.kernel.mad) + '</span>' : '<span class="na">&mdash;</span>';
      s += '<td>' + kernelHtml + '</td>';
    }
    return s + '</tr>';
  }

  BOARD_CONFIGS.forEach(function(bc) {
    var key = bc.label;
    var size = bc.rows * bc.cols;

    html += sectionRow('Board: ' + key + ' (' + size + ' cells)');

    html += row('Plague spread (JS)', function(r) { return r['spread_' + key]; });
    html += row('Masked softmax (JS)', function(r) { return r['softmax_' + key]; });
    html += row('Canvas render', function(r) { return r['render_' + key]; });

    BATCH_SIZES.forEach(function(bs) {
      html += row('Dense forward (b=' + bs + ')', function(r) { return r['dense_fwd_' + key + '_b' + bs]; });
    });
    html += row('Dense train (b=64)', function(r) { return r['dense_train_' + key + '_b64']; });
    html += row('Dense train (b=256)', function(r) { return r['dense_train_' + key + '_b256']; });
    html += row('Full tick (40 games)', function(r) { return r['tick_' + key]; });

    if (size >= 100) {
      BATCH_SIZES.forEach(function(bs) {
        html += row('Spatial forward (b=' + bs + ')', function(r) { return r['spatial_fwd_' + key + '_b' + bs]; });
      });
      html += row('Spatial train (b=64)', function(r) { return r['spatial_train_' + key + '_b64']; });
    }
  });

  html += '</tbody></table>';
  wrap.innerHTML = html;
}

// ═══════════════════════════════════
//  Entry points
// ═══════════════════════════════════

function disableButtons(d) {
  var btns = document.querySelectorAll('button');
  for (var i = 0; i < btns.length; i++) btns[i].disabled = d;
}

async function runSingle(backend) {
  if (running) return;
  running = true; disableButtons(true); __sink = 0; progress(0);
  var r = await benchmarkBackend(backend, function(s,t) { progress(Math.round(s/t*100)); });
  if (r) { results[backend] = r; renderResults(); }
  console.log('DCE sink:', __sink);
  status('Done (' + backend + ')');
  progress(100); running = false; disableButtons(false);
}

async function runAll() {
  if (running) return;
  running = true; disableButtons(true); results = {}; __sink = 0; progress(0);

  var backends = ['cpu'];
  try { await setBackend('wasm'); backends.push('wasm'); await setBackend('cpu'); } catch(e) {}
  try { await setBackend('webgl'); backends.push('webgl'); await setBackend('cpu'); } catch(e) {}
  if (navigator.gpu) {
    try { await setBackend('webgpu'); backends.push('webgpu'); await setBackend('cpu'); } catch(e) {}
  }
  status('Backends: ' + backends.join(', '));
  await sleep(500);

  for (var i = 0; i < backends.length; i++) {
    var r = await benchmarkBackend(backends[i], function(s,t) {
      progress(Math.round((i/backends.length + s/t/backends.length)*100));
    });
    if (r) { results[backends[i]] = r; renderResults(); }
    await sleep(200);
  }

  console.log('DCE sink:', __sink);
  status('All benchmarks complete.');
  progress(100); running = false; disableButtons(false);
}
</script>
</body>
</html>
